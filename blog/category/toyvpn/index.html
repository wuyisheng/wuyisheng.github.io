<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link href=https://wuyisheng.github.io/blog/category/toyvpn/ rel=canonical><link href=../sphinx-docs/ rel=prev><link href=../../archive/2025/ rel=next><link rel=icon href=../../../assets/images/favicon.png><meta name=generator content="mkdocs-1.6.1, mkdocs-material-9.6.9"><title>toyvpn - Yeshen blog</title><link rel=stylesheet href=../../../assets/stylesheets/main.4af4bdda.min.css><link rel=stylesheet href=../../../assets/stylesheets/palette.06af60db.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style><script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=brown data-md-color-accent=deep-orange> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#toyvpn class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <header class="md-header md-header--shadow" data-md-component=header> <nav class="md-header__inner md-grid" aria-label=Header> <a href=../../.. title="Yeshen blog" class="md-header__button md-logo" aria-label="Yeshen blog" data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> Yeshen blog </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> toyvpn </span> </div> </div> </div> <div class=md-header__source> <a href=https://github.com/wuyisheng/wuyisheng.github.io title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg> </div> <div class=md-source__repository> GitHub </div> </a> </div> </nav> </header> <div class=md-container data-md-component=container> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../../.. title="Yeshen blog" class="md-nav__button md-logo" aria-label="Yeshen blog" data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg> </a> Yeshen blog </label> <div class=md-nav__source> <a href=https://github.com/wuyisheng/wuyisheng.github.io title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg> </div> <div class=md-source__repository> GitHub </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_1 checked> <label class=md-nav__link for=__nav_1 id=__nav_1_label tabindex=0> <span class=md-ellipsis> Blog </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_1_label aria-expanded=true> <label class=md-nav__title for=__nav_1> <span class="md-nav__icon md-icon"></span> Blog </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../ class=md-nav__link> <span class=md-ellipsis> Blog </span> </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_1_2> <label class=md-nav__link for=__nav_1_2 id=__nav_1_2_label tabindex=0> <span class=md-ellipsis> Archive </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_1_2_label aria-expanded=false> <label class=md-nav__title for=__nav_1_2> <span class="md-nav__icon md-icon"></span> Archive </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../archive/2025/ class=md-nav__link> <span class=md-ellipsis> 2025 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_1_3 checked> <label class=md-nav__link for=__nav_1_3 id=__nav_1_3_label tabindex=0> <span class=md-ellipsis> Categories </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_1_3_label aria-expanded=true> <label class=md-nav__title for=__nav_1_3> <span class="md-nav__icon md-icon"></span> Categories </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../sphinx-docs/ class=md-nav__link> <span class=md-ellipsis> sphinx-docs </span> </a> </li> <li class="md-nav__item md-nav__item--active"> <input class="md-nav__toggle md-toggle" type=checkbox id=__toc> <a href=./ class="md-nav__link md-nav__link--active"> <span class=md-ellipsis> toyvpn </span> </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../../.. class=md-nav__link> <span class=md-ellipsis> About </span> </a> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <div class=md-content__inner> <header class=md-typeset> <h1 id=toyvpn>toyvpn</h1> </header> <article class="md-post md-post--excerpt"> <header class=md-post__header> <div class="md-post__meta md-meta"> <ul class=md-meta__list> <li class=md-meta__item> <time datetime="2025-03-19 00:00:00+00:00">March 19, 2025</time></li> <li class=md-meta__item> in <a href=./ class=md-meta__link>toyvpn</a></li> <li class=md-meta__item> 8 min read </li> </ul> </div> </header> <div class="md-post__content md-typeset"> <h2 id=toyvpn><a href=../../2025/03/19/toyvpn-%E8%AF%A6%E8%A7%A3/ class=toclink>Toyvpn 详解</a></h2> <p>Android中可以使用提供了vpn服务，通过VPN builder，可以创建一个网络接口(https://developer.android.google.cn/reference/android/net/VpnService.Builder#establish())，拦截特定或者部分app的流量。</p> <p>上面的文档提供了比较详细的说明，还有一份服务端+客户端的demo代码。</p> <blockquote> <p>https://developer.android.google.cn/develop/connectivity/vpn?hl=zh-cn#service https://android.googlesource.com/platform/development/+/master/samples/ToyVpn</p> </blockquote> <h2 id=_1><a class=toclink href=../../2025/03/19/toyvpn-%E8%AF%A6%E8%A7%A3/#_1>服务端部分</a></h2> <p>There are several ways to play with this program. Here we just give an example for the simplest scenario. Let us say that a Linux box has a public IPv4 address on eth0. Please try the following steps and adjust the parameters when necessary.</p> <h3 id=enable-ip-forwarding><a class=toclink href=../../2025/03/19/toyvpn-%E8%AF%A6%E8%A7%A3/#enable-ip-forwarding>Enable IP forwarding</a></h3> <pre><code class=language-sh>echo 1 &gt; /proc/sys/net/ipv4/ip_forward
</code></pre> <p>作用：允许Linux系统转发IP数据包（作为路由器功能）。 原理：将内核参数 net.ipv4.ip_forward 设为 1，使流量能在不同网络接口间传递。</p> <h3 id=pick-a-range-of-private-addresses-and-perform-nat-over-eth0><a class=toclink href=../../2025/03/19/toyvpn-%E8%AF%A6%E8%A7%A3/#pick-a-range-of-private-addresses-and-perform-nat-over-eth0>Pick a range of private addresses and perform NAT over eth0.</a></h3> <pre><code class=language-sh>iptables -t nat -A POSTROUTING -s 10.0.0.0/8 -o eth0 -j MASQUERADE
</code></pre> <p>作用：将来自私有网络 10.0.0.0/8 的流量通过公网接口 eth0 进行NAT转换（隐藏客户端真实IP）。 原理：MASQUERADE 规则会动态修改数据包源地址为 eth0 的公网IP，使返回流量能正确路由。</p> <h3 id=create-a-tun-interface><a class=toclink href=../../2025/03/19/toyvpn-%E8%AF%A6%E8%A7%A3/#create-a-tun-interface>Create a TUN interface.</a></h3> <pre><code class=language-sh>ip tuntap add dev tun0 mode tun
</code></pre> <p>作用：创建一个名为 tun0 的TUN模式虚拟接口，用于处理VPN隧道的三层（IP层）数据包。 TUN特点：传输原始IP数据包，需用户态程序（如 ToyVpnServer）处理封包逻辑。</p> <h3 id=set-the-addresses-and-bring-up-the-interface><a class=toclink href=../../2025/03/19/toyvpn-%E8%AF%A6%E8%A7%A3/#set-the-addresses-and-bring-up-the-interface>Set the addresses and bring up the interface.</a></h3> <pre><code class=language-sh>ifconfig tun0 10.0.0.1 dstaddr 10.0.0.2 up
</code></pre> <p>作用： 为 tun0 设置本地IP 10.0.0.1，并指定对端（客户端）IP为 10.0.0.2。 up 表示启用接口。 关键参数： dstaddr 定义隧道的目标地址（客户端IP），需与后续服务器命令中的 -a 参数一致。</p> <h3 id=create-a-server-on-port-8000-with-shared-secret-test><a class=toclink href=../../2025/03/19/toyvpn-%E8%AF%A6%E8%A7%A3/#create-a-server-on-port-8000-with-shared-secret-test>Create a server on port 8000 with shared secret "test".</a></h3> <pre><code class=language-sh>./ToyVpnServer tun0 8000 test -m 1400 -a 10.0.0.2 32 -d 8.8.8.8 -r 0.0.0.0 0
</code></pre> <p>参数解析： tun0：绑定到TUN接口。 8000：监听UDP端口8000。 test：共享密钥（明文，无加密）。 -m 1400：设置MTU为1400字节（避免分片）。 -a 10.0.0.2 32：为客户端分配IP 10.0.0.2，子网掩码32位（单地址）。 -d 8.8.8.8：指定客户端DNS服务器为Google DNS。 -r 0.0.0.0 0：添加默认路由（0.0.0.0/0），将所有流量导向VPN隧道。</p> <p>This program only handles a session at a time. To allow multiple sessions, multiple servers can be created on the same port, but each of them requires its own TUN interface. A short shell script will be sufficient. Since this program is designed for demonstration purpose, it performs neither strong authentication nor encryption. DO NOT USE IT IN PRODUCTION!</p> <p>该程序一次只能处理一个连接。若需多会话，需为每个客户端创建独立的TUN接口（如 tun1, tun2）并启动多个服务器进程。 无加密：共享密钥 test 以明文传输，易被窃听或篡改。 无身份验证：仅依赖简单密钥，无法防止中间人攻击。 仅限测试：注释明确警告不可用于实际生产环境。</p> <h3 id=_2><a class=toclink href=../../2025/03/19/toyvpn-%E8%AF%A6%E8%A7%A3/#_2>相关代码</a></h3> <pre><code class=language-c>// int tun_fd = get_interface(&quot;tun0&quot;);
// 执行后，系统中会出现 tun0 接口（可通过 ip addr show tun0 查看）。
static int get_interface(char *name)
{

    // **/dev/net/tun**：Linux内核提供的TUN/TAP设备文件，用于创建虚拟网络接口。
    // **O_RDWR**：以读写模式打开设备。
    // **O_NONBLOCK**：设为非阻塞模式（后续读写操作不会阻塞进程）。
    // 返回值：文件描述符 interface，用于后续操作（如读写数据包）。
    // 初始化接口请求结构体 
    int interface = open(&quot;/dev/net/tun&quot;, O_RDWR | O_NONBLOCK);

    // **ifreq**：用于配置网络接口参数的结构体（定义在 &lt;net/if.h&gt;）
    ifreq ifr;
    memset(&amp;ifr, 0, sizeof(ifr));

    // **IFF_TUN**：创建TUN设备（处理IP层数据包，对应三层网络层）。
    // **IFF_NO_PI**：禁用包头信息（Packet Information），直接传输原始IP数据包。
    // 若未设置此标志，数据包会附加4字节的包头（如协议类型）。
    ifr.ifr_flags = IFF_TUN | IFF_NO_PI;

    // 将用户传入的接口名称（如 &quot;tun0&quot;）复制到 ifr.ifr_name。
    // 注意：strncpy 不会自动补全终止符 \0，需确保 name 长度不超过 IFNAMSIZ（通常为16字节）。
    strncpy(ifr.ifr_name, name, sizeof(ifr.ifr_name));

    // **ioctl**：通过 TUNSETIFF 命令将配置应用到TUN设备。
    // 成功：内核会创建名为 name 的TUN接口（如 tun0）。
    // 失败：输出错误信息并终止程序（如权限不足或名称冲突）。
    // 返回文件描述符  
    if (ioctl(interface, TUNSETIFF, &amp;ifr)) {
        perror(&quot;Cannot get TUN interface&quot;);
        exit(1);
    }

    return interface;
}
</code></pre> <pre><code class=language-c>// 创建一个UDP服务器，监听指定端口，接收数据包直到收到一个符合特定格式（首字节为0，后面是正确密钥）的数据包，
// 然后与该客户端建立连接，返回socket描述符以供后续通信。
// 这个函数用于在VPN服务器中建立初始的隧道连接，确保客户端提供正确的密钥，并只处理一个客户端。
// port：监听的UDP端口。
// secret：预共享密钥，用于验证客户端。
// 返回值：成功返回连接后的socket文件描述符，失败返回 -1。
static int get_tunnel(char *port, char *secret)
{
    // We use an IPv6 socket to cover both IPv4 and IPv6.
    // 使用 IPv6协议族 (AF_INET6) 创建UDP Socket (SOCK_DGRAM)。
    // 目的：通过IPv6双栈支持，同时监听IPv4和IPv6客户端（需系统支持）。
    // IPv4兼容性依赖系统配置,需确保系统支持IPv4映射地址（sysctl net.ipv6.bindv6only=0）。
    int tunnel = socket(AF_INET6, SOCK_DGRAM, 0);
    int flag = 1;
    // **SO_REUSEADDR**：允许绑定处于 TIME_WAIT 状态的地址，快速重启服务。
    // **IPV6_V6ONLY=0**：允许Socket接收IPv4映射的IPv6地址（如 ::ffff:192.168.1.1）。
    setsockopt(tunnel, SOL_SOCKET, SO_REUSEADDR, &amp;flag, sizeof(flag));
    flag = 0;
    setsockopt(tunnel, IPPROTO_IPV6, IPV6_V6ONLY, &amp;flag, sizeof(flag));

    // Accept packets received on any local address.
    sockaddr_in6 addr;
    memset(&amp;addr, 0, sizeof(addr));
    addr.sin6_family = AF_INET6;
    addr.sin6_port = htons(atoi(port));

    // Call bind(2) in a loop since Linux does not have SO_REUSEPORT.
    // 循环绑定：若端口被占用 (EADDRINUSE)，等待0.1秒后重试，直至成功。
    while (bind(tunnel, (sockaddr *)&amp;addr, sizeof(addr))) {
        if (errno != EADDRINUSE) {
            return -1;
        }
        usleep(100000);
    }

    // Receive packets till the secret matches.
    char packet[1024];
    socklen_t addrlen;
    // 数据包格式：首个字节为 0，后续为密钥字符串（如 \0test）。
    // 验证逻辑：
    // 若首字节非 0 或密钥不匹配，继续接收新数据包。
    // 密钥匹配后退出循环。
    do {
        addrlen = sizeof(addr);
        int n = recvfrom(tunnel, packet, sizeof(packet), 0,
                (sockaddr *)&amp;addr, &amp;addrlen);
        if (n &lt;= 0) {
            return -1;
        }
        packet[n] = 0;
    } while (packet[0] != 0 || strcmp(secret, &amp;packet[1]));

    // Connect to the client as we only handle one client at a time.
    // 目的：将UDP Socket与客户端地址绑定，后续通信可使用 send/recv 替代 sendto/recvfrom。
    // 影响：该Socket仅处理来自此客户端的流量，实现单会话独占。
    connect(tunnel, (sockaddr *)&amp;addr, addrlen);
    return tunnel;
}

</code></pre> <pre><code class=language-c>// Get TUN interface.
// TUN设备用于与内核网络栈交互（如接收/发送IP层数据包）
int interface = get_interface(argv[1]);

// Wait for a tunnel.
int tunnel;
// get_tunnel 创建UDP服务端，监听指定端口，验证客户端密钥，返回已连接的socket描述符 tunnel。
// 单客户端限制：每个循环仅处理一个客户端，断开后才接受下一个连接。
while ((tunnel = get_tunnel(argv[2], argv[3])) != -1) {
    printf(&quot;%s: Here comes a new tunnel\n&quot;, argv[1]);

    // On UN*X, there are many ways to deal with multiple file
    // descriptors, such as poll(2), select(2), epoll(7) on Linux,
    // kqueue(2) on FreeBSD, pthread(3), or even fork(2). Here we
    // mimic everything from the client, so their source code can
    // be easily compared side by side.

    // Put the tunnel into non-blocking mode.
    // 确保 send/recv 不会阻塞进程，允许轮询多个文件描述符（尽管此处未实现多路复用）。
    fcntl(tunnel, F_SETFL, O_NONBLOCK);

    // Send the parameters several times in case of packet loss.
    // 向客户端重复发送3次 parameters。
    // 目的：应对UDP丢包，提高参数传递可靠性。
    for (int i = 0; i &lt; 3; ++i) {
        send(tunnel, parameters, sizeof(parameters), MSG_NOSIGNAL);
    }

    // Allocate the buffer for a single packet.
    // // 缓冲区（最大支持32KB数据包）
    char packet[32767];

    // We use a timer to determine the status of the tunnel. It
    // works on both sides. A positive value means sending, and
    // any other means receiving. We start with receiving.
     // 状态计时器（正=发送，负=接收）
    int timer = 0;

    // We keep forwarding packets till something goes wrong.
    // 优势：单线程处理双向流量，代码简洁。
    // 劣势：高负载下频繁休眠可能导致延迟；未使用 poll/epoll 等多路复用机制，效率较低。
    while (true) {
        // Assume that we did not make any progress in this iteration.
        bool idle = true;

        // Read the outgoing packet from the input stream.
        // TUN → 隧道：读取内核发出的IP数据包（如来自客户端的流量），通过UDP隧道发送给客户端。
        int length = read(interface, packet, sizeof(packet));
        if (length &gt; 0) {
            // Write the outgoing packet to the tunnel.
            send(tunnel, packet, length, MSG_NOSIGNAL);

            // There might be more outgoing packets.
            idle = false;

            // If we were receiving, switch to sending.
            if (timer &lt; 1) {
                timer = 1;
            }
        }

        // Read the incoming packet from the tunnel.
        // 隧道 → TUN：接收客户端发来的数据包，写入TUN接口（最终进入内核网络栈）。
        length = recv(tunnel, packet, sizeof(packet), 0);
        if (length == 0) {
            break;
        }
        if (length &gt; 0) {
            // Ignore control messages, which start with zero.
            if (packet[0] != 0) {
                // Write the incoming packet to the output stream.
                write(interface, packet, length);
            }

            // There might be more incoming packets.
            idle = false;

            // If we were sending, switch to receiving.
            if (timer &gt; 0) {
                timer = 0;
            }
        }

        // If we are idle or waiting for the network, sleep for a
        // fraction of time to avoid busy looping.
        if (idle) {
            usleep(100000);  // 休眠100ms避免忙等待

            // Increase the timer. This is inaccurate but good enough,
            // since everything is operated in non-blocking mode.
            timer += (timer &gt; 0) ? 100 : -100;

            // We are receiving for a long time but not sending.
            // Can you figure out why we use a different value? :)
            // 长时间未收到响应（接收超时）
            // 心跳机制：接收超时后发送控制包（首字节 0），维持NAT映射或检测存活。
            // 超时阈值：-16000（约16秒）和 20000（约20秒）基于累计的休眠时间估算。

            // 发送状态（timer &gt; 0）：累计正值，超时断开。
            // 接收状态（timer ≤ 0）：累计负值，超时发送心跳包。
            // 目的：检测单向通信故障（如客户端掉线但未发送FIN）。
            if (timer &lt; -16000) {
                // Send empty control messages.
                packet[0] = 0;
                for (int i = 0; i &lt; 3; ++i) {
                     // 发送空控制包（心跳）
                    send(tunnel, packet, 1, MSG_NOSIGNAL);
                }

                // Switch to sending.
                timer = 1;
            }

            // We are sending for a long time but not receiving.
            if (timer &gt; 20000) {
                break;
            }
        }
    }
    printf(&quot;%s: The tunnel is broken\n&quot;, argv[1]);
    close(tunnel);
}

</code></pre> <h2 id=_3><a class=toclink href=../../2025/03/19/toyvpn-%E8%AF%A6%E8%A7%A3/#_3>客户端部分</a></h2> <blockquote> <p>https://developer.android.google.cn/develop/connectivity/vpn?hl=zh-cn#service</p> </blockquote> <h3 id=vpnservicebuilderestablish><a class=toclink href=../../2025/03/19/toyvpn-%E8%AF%A6%E8%A7%A3/#vpnservicebuilderestablish>VpnService.Builder.establish</a></h3> <p>在Android开发中，VpnService.Builder.establish() 方法返回的文件描述符（File Descriptor, fd）是VPN功能的核心，它允许应用拦截和处理设备的网络流量。该fd代表一个TUN虚拟网络接口，用于在系统和应用之间传输原始IP数据包。当VPN激活时，系统将符合路由规则的流量重定向到此接口，应用通过读取fd获取设备发出的数据包，处理后转发到目标服务器；同时将服务器返回的数据写入fd，系统会将其传递给接收应用。</p> <p>出站流量：应用从fd读取的是设备发送的原始IP包（如TCP/UDP/ICMP）。 入站流量：应用构造响应IP包并写入fd，系统会将其视为来自外部网络的数据。</p> <p>VpnService 的 fd 操作的是 IP 层 的原始数据包（基于 TUN 设备），而非传输层（TCP/UDP）。这意味着：</p> <p>读取时：从 fd 读取的是一个完整的 IP 数据包（IPv4 或 IPv6），其载荷可能包含 TCP、UDP、ICMP 或其他协议的数据。 写入时：必须构造一个完整的 IP 数据包（包含正确的 IP 头和校验和），系统才会将其视为合法的入站流量。</p> <p>IP 头部：包含协议类型（Protocol 字段，如 6 表示 TCP，17 表示 UDP）。 传输层数据：在 IP 头部之后，例如 TCP 头部及其载荷。</p> <p><strong>读取流程：</strong></p> <p>从 fd 读取二进制数据，得到一个原始 IP 数据包。 解析 IP 头部的 Protocol 字段，确定是 TCP（6）、UDP（17）还是其他协议。 根据协议类型，继续解析后续的 TCP/UDP 头部（如端口号、校验和等）。</p> <p><strong>写入流程：</strong></p> <p>构造一个完整的 IP 数据包（需手动设置 IP 头部字段）。 填充传输层数据（如 TCP/UDP 头部及其载荷）。 计算 IP 头部和传输层头部的校验和。 将二进制数据写入 fd。</p> <h3 id=addallowedapplication><a class=toclink href=../../2025/03/19/toyvpn-%E8%AF%A6%E8%A7%A3/#addallowedapplication>addAllowedApplication</a></h3> <pre><code class=language-java>VpnService.Builder builder = new VpnService.Builder();
builder.addAllowedApplication(&quot;com.example.app1&quot;); // 指定生效的包名
builder.addAllowedApplication(&quot;com.example.app2&quot;);
ParcelFileDescriptor fd = builder.establish();
</code></pre> <p>生效规则为白名单机制：调用 addAllowedApplication 后，只有指定的应用流量会经过 VPN。若不调用此方法，默认所有应用的流量都会经过 VPN（全局 VPN）。</p> <p>Android 系统为每个应用分配唯一的 UID。addAllowedApplication 会根据包名查询应用的 UID，并在内核网络规则中标记这些 UID 的流量。流量重定向通过 iptables 规则实现（如 fwmark 标记）。</p> <p>即使未调用 addAllowedApplication，也可以通过 addRoute 控制哪些 IP 范围的流量经过 VPN。但 addAllowedApplication 优先级更高：如果指定了应用白名单，即使 IP 符合路由规则，非白名单应用的流量也不会经过 VPN。</p> <p><strong>注意事项</strong></p> <p>必须在 establish() 前调用：配置需在建立 VPN 连接前完成。 系统应用限制：无法控制系统级应用（如 android 包名）的流量。 动态生效：若应用在 VPN 连接后安装，需重新建立 VPN 连接才能生效。</p> <h3 id=_4><a class=toclink href=../../2025/03/19/toyvpn-%E8%AF%A6%E8%A7%A3/#_4>相关代码</a></h3> <pre><code class=language-java>// 优化点：
// 多线程处理：分离读写线程以提高吞吐量。
// 缓冲区池：复用 ByteBuffer 减少内存分配开销。
// Create a DatagramChannel as the VPN tunnel.
try (DatagramChannel tunnel = DatagramChannel.open()) {

    // Protect the tunnel before connecting to avoid loopback.
    // **mService.protect()**：确保 UDP socket 绕过 VPN 自身，避免数据循环。
    if (!mService.protect(tunnel.socket())) {
        throw new IllegalStateException(&quot;Cannot protect the tunnel&quot;);
    }

    // Connect to the server.
    // **tunnel.connect()**：连接到 VPN 服务器的 UDP 端口。
    tunnel.connect(server);

    // For simplicity, we use the same thread for both reading and
    // writing. Here we put the tunnel into non-blocking mode.
    tunnel.configureBlocking(false);

    // Authenticate and configure the virtual network interface.
    iface = handshake(tunnel);

    // Now we are connected. Set the flag.
    connected = true;

    // **FileInputStream**：从虚拟接口读取本地应用待发送的数据包。
    // **FileOutputStream**：将接收到的数据包写入虚拟接口，供本地应用处理。
    // **ByteBuffer**：缓冲区，用于临时存储单个数据包。
    // Packets to be sent are queued in this input stream.
    FileInputStream in = new FileInputStream(iface.getFileDescriptor());

    // Packets received need to be written to this output stream.
    FileOutputStream out = new FileOutputStream(iface.getFileDescriptor());

    // Allocate the buffer for a single packet.
    ByteBuffer packet = ByteBuffer.allocate(MAX_PACKET_SIZE);

    // Timeouts:
    //   - when data has not been sent in a while, send empty keepalive messages.
    //   - when data has not been received in a while, assume the connection is broken.
    long lastSendTime = System.currentTimeMillis();
    long lastReceiveTime = System.currentTimeMillis();

    // We keep forwarding packets till something goes wrong.
    while (true) {
        // Assume that we did not make any progress in this iteration.
        boolean idle = true;

        // Read the outgoing packet from the input stream.
        // // 处理发送数据（本地应用 -&gt; 服务器）
        int length = in.read(packet.array());
        if (length &gt; 0) {
            // Write the outgoing packet to the tunnel.
            packet.limit(length);
            tunnel.write(packet);
            packet.clear();

            // There might be more outgoing packets.
            idle = false;
            lastReceiveTime = System.currentTimeMillis();
        }

        // Read the incoming packet from the tunnel.
        // 处理接收数据（服务器 -&gt; 本地应用）
        length = tunnel.read(packet);
        if (length &gt; 0) {
            // Ignore control messages, which start with zero.
            // 忽略控制消息（首字节为0）
            if (packet.get(0) != 0) {
                // Write the incoming packet to the output stream.
                // 转发至本地应用
                out.write(packet.array(), 0, length);
            }
            packet.clear();

            // There might be more incoming packets.
            idle = false;
            lastSendTime = System.currentTimeMillis();
        }

        // If we are idle or waiting for the network, sleep for a
        // fraction of time to avoid busy looping.
        if (idle) {
            Thread.sleep(IDLE_INTERVAL_MS);
            final long timeNow = System.currentTimeMillis();

            // 保活包：定期发送首字节为 0 的空包，防止 NAT 超时断开。
            // 超时断开：超过 RECEIVE_TIMEOUT_MS 未收到数据，认为连接已中断。
            if (lastSendTime + KEEPALIVE_INTERVAL_MS &lt;= timeNow) {
                // We are receiving for a long time but not sending.
                // Send empty control messages.
                // 长时间未发送数据：发送空保活包
                packet.put((byte) 0).limit(1);
                for (int i = 0; i &lt; 3; ++i) {
                    packet.position(0);
                    tunnel.write(packet);
                }
                packet.clear();
                lastSendTime = timeNow;
            // 长时间未接收数据：断开连接
            } else if (lastReceiveTime + RECEIVE_TIMEOUT_MS &lt;= timeNow) {
                // We are sending for a long time but not receiving.
                throw new IllegalStateException(&quot;Timed out&quot;);
            }
        }
    }
} catch (SocketException e) {
    Log.e(getTag(), &quot;Cannot use socket&quot;, e);
} finally {
    if (iface != null) {
        try {
            iface.close();
        } catch (IOException e) {
            Log.e(getTag(), &quot;Unable to close interface&quot;, e);
        }
    }
}

</code></pre> <h2 id=_5><a class=toclink href=../../2025/03/19/toyvpn-%E8%AF%A6%E8%A7%A3/#_5>小结</a></h2> <p>总的来说，linux和android上都有接口，创建/使用虚拟网卡，提供了拦截/发送 IP数据包的能力。toyvpn中基于udp数据包，把android中的IP数据包转发到linux上。</p> <p>实际体验下来，很不稳定，终归是toy。</p> </div> </article> <nav class=md-pagination> </nav> </div> </div> <script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script> </div> </main> <footer class=md-footer> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> <div class=md-copyright__highlight> Copyright &copy; 2015-2025 yeshen.org </div> </div> <div class=md-social> <a href="mailto:<hello@yeshen.org>" target=_blank rel=noopener title="contact me" class=md-social__link> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 512 512"><!-- Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M498.1 5.6c10.1 7 15.4 19.1 13.5 31.2l-64 416c-1.5 9.7-7.4 18.2-16 23s-18.9 5.4-28 1.6L284 427.7l-68.5 74.1c-8.9 9.7-22.9 12.9-35.2 8.1S160 493.2 160 480v-83.6c0-4 1.5-7.8 4.2-10.8l167.6-182.8c5.8-6.3 5.6-16-.4-22s-15.7-6.4-22-.7L106 360.8l-88.3-44.2C7.1 311.3.3 300.7 0 288.9s5.9-22.8 16.1-28.7l448-256c10.7-6.1 23.9-5.5 34 1.4"/></svg> </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "../../..", "features": [], "search": "../../../assets/javascripts/workers/search.f8cc74c7.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script> <script src=../../../assets/javascripts/bundle.c8b220af.min.js></script> </body> </html>